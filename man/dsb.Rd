% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MiscFuns.R
\name{dsb}
\alias{dsb}
\title{Extends strings with variables using the Dot Square Bracket operator (experimental)}
\usage{
dsb(x, split = NULL, collapse = NULL, frame = parent.frame())
}
\arguments{
\item{x}{A character string, must be of length 1. Every expression inside \code{.[]} is evaluated in the current frame and then coerced to character and inserted into the character string. For example: \code{dsb("hello .[name]")} is equivalent to \code{paste0("hello ", name)}.
You can add a string literal as first element in the \code{.[]}, followed by a comma or a slash. Doing so \emph{the behavior will change}!
If \code{.['s', expr]}, the expression will be evaluated and collapsed: \code{paste0(expr, collapse = "s")} is applied before merging to the existing string. If \code{'s'} is missing, the default is the empty string.
If \code{".['s'/expr]"}, the expression \code{expr} is \emph{not evaluated and taken verbatim}, then split according to \code{'s'} to create a vector. The value of split is fixed, but can start with an \code{@}, if so it is taken as a regular expression. If \code{'s'} is missing (as in \code{.[/expr]}), the default is comma separation: i.e. \code{.['@, *'/expr]}.}

\item{split}{Character scalar, default is \code{NULL}. If provided, the character in \code{x} will be broken into a vector according to the value in \code{split}. Ex \code{dsb("a.b.c.", split = ".")} will create the vector of \code{a}, \code{b} and \code{c}. You can use a regular expression by starting with an \code{@}, like in \code{"@[[:punct:]]"}. If you really want to start with an \code{@}, escape it like in \code{"\\@"}.}

\item{collapse}{If the variables inserted into the string are of length greater than 1, you can merge into a single string with \code{collapse}.}

\item{frame}{Environment in which to evaluate the variables in \code{.[]}, defaults to \code{parent.frame()}.

Every expression inside \code{.[]} is evaluated in the current frame and then coerced to character and inserted into the character string.

If \code{split} is used and if \code{.[]} is also used and returns a vector, that vector is accumulated. Ex: \code{dsb("a, .[x], c", split = ", ")}, if x returns \code{c("x1", "x2")}, the final vector returned will be \code{c("a", "x1", "x2", "c")}.

If both \code{split} and \code{collapse} are provided, they will be applied in the order chosen by the user. Placing \code{collapse} last will always return a vector of length 1. That's not the case if it is placed before \code{split}.

Nesting \code{.[]}, like in \code{dsb(".[/a, b, .[x]]")}, is currently not possible and will lead to an error.}
}
\value{
A character vector. It is of length > 1 only if the variables inserted are of length > 1 or if \code{split} is provided.
}
\description{
(\emph{Currently experimental, design will likely evolve.}) Simple utility to insert variables into character strings using the "dot square bracket" operator. Typically \code{dsb("Hello I'm .[x]!")} is equivalent to \code{paste0("hello I'm ", x, "!")}.
}
\section{Collapsing}{


If the expression inside \code{.[]} is a vector, a vector will be returned, except when we explicitly request the character string to be "collapsed". There are two main ways to do the collapsing that we detail below. Throughout, consider that the variable \code{name} is equal to \code{name = c("Romeo", "Juliet")} and the example \code{dsb("hello .[name], what's up?")}.


\itemize{

\item{full collapse:}{The argument \code{collapse} is used. All the string elements are attached. For example \code{dsb("hello .[name], what's up?", collapse = " And... ")} leads to \code{"hello Romeo, what's up? And... hello Juliet, what's up?"}.}
\item{expression-collapse:}{There is a string literal in the first position of \code{.[]}. In that case the expression in brackets is first collapsed before being merged. For example in \code{dsb("hello .[' and ', name], what's up?")} leads to \code{"hello Romeo and Juliet, what's up?"}. If you add a comma but omit the string literal, the default is to collapse with a space: \code{.[,expr]} is equivalent to \code{.[" ", expr]}.}

}
}

\section{Splitting}{


There are two ways to split: either using the argument \code{split}, either using the within \code{.[]} splitting operator. We detail them below.

\itemize{

\item{\code{split} argument:}{The argument \code{split} splits the character string according to a character string. For example: \code{dsb("a.b.c", split = ".")} becomes \code{c("a", "b", "c")}. By default the character is fixed, but you can make it a regular expression by adding an \code{"@"} first. For example \code{dsb("a.b; c", split = "@[[:punct:] ]+")} would also lead to the same vector. Note that if \code{.[]} is present in the string and would lead to a vector, the value is concatenated.}
\item{In \code{.[]} splitting:}{In the code of the form \code{.['s'/expr]}, the expression \code{expr} \emph{is not evaluated} and is split according to \code{'s'}. The syntax is: a) a string literal, b) a slash, c) an unevaluated expression.
For example \code{dsb("x.['.'/a.b.c]")} will first break \code{"a.b.c"} in to the vector from \code{a} to \code{c} which will then merged to \code{x}, leading to \code{c("xa", "xb", "xc")}.
To enable regular expressions, as before, you must use an \code{@} first in the string literal.
Finally, the default value, when no string literal is provided, is \code{"@, *"}, which means comma-separated. For example \code{dsb("x.[/a, b, c]")} will lead to the same vector as before.}

}
}

\examples{

guy_all = c("Jenny", "Bryan")
loc_all = c("kitchen", "bathroom")

guy = sample(guy_all, 1)
loc = sample(loc_all, 1)

dsb("Where is .[guy]? .[guy] is in the .[loc].")

# Since the stuff in brackets is evaluated in the current frame,
# you can do things like:

guy_gen = function() sample(guy_all, 1)
loc_gen = function() sample(loc_all, 1)

dsb("Where is .[g <- guy_gen()]? .[g] is in the .[loc_gen()].")


#
# Collapsing options
#

name = c("Romeo", "Juliet")

# full collapse with argument collapse
dsb("hello .[name], what's up?", collapse = " and ")

# collapse the expression by adding a string literal
# in the *first* position of .[]
dsb("hello .[' and ', name], what's up?")

# The elements can also be empty, leading to collapse with a " "
dsb("hello .[, name], what's up?")

# Another example
n = 5
dsb(".[n]! = .['*', 1:n]")


#
# Splitting options
#

# You can split with the argument split
dsb("This.is.a.list.of.tings", split = ".")

# When split is used, vectors in .[] are concatenated
dsb("a.b..[letters[3:8]].y.z..[1:3]", split = ".")

# You can split using the .[],
# by adding a character literal before a slash:
dsb("library(.['.'/MASS.lme3])")

# By default the split is comma-separated:
dsb("\\\\usepackage{.[/lmodern, xcolor, array]}")

# Since there is no evaluation when split is requested,
# you can have anything you want in .[]
dsb("character = .[''/*$Â£?/]")


}
\author{
Laurent Berge
}
